# 数据绑定

1、实现observer
实现 observer 思路：我们知道Object.defineProperty的特性了， 我们就利用它的set和get。。我们将要observe的对象， 通过递归，将它所有的属性，包括子属性的属性，都给加上set和get，这样的话，给这个对象的某个属性赋值，就会触发set。。

## 监听数据变化

Observe

set值成功是因为闭包，val值会一直存在

## 问题

1. 监听数组变化
2. 监听新加的属性或重新给一个对象赋值（使用set，后面看）

### 监听数组变化

> __proto__, 这个属性指向该对象的原型
> __proto__ = arrayAugmentations （每次调用方法时会arrayAugmentations中对push方法，可以做监听处理，然后调用原生的push方法）
> push 方法中收到通知也只是知道数组修改了，至于是哪个元素修改了并不知道。所以才会有启发式diff算法的介入。

**其他**：

因为Array构造函数执行时不会对传进去的this做任何处理。不止Array，String,Number,Regexp,Object等等JS的内置类都不行。
Object.apply({a:'1'})跟你执行Object()得到的对象一模一样。而我们自己写的Father却不会。

ES5及以下JS无法完美继承数组：

1. 因为数据有个响应式的 length
2. 数组内部的 [[class]] 属性

因为这两种我们无法在 js 层面实现。

（暂时不知道异化后的是啥？？）当然还有Vue先判断了一下是否能使用__proto__，不能的话最后采用直接给实例数组上挂异化后的push方法的形式来完成。

## computed

注意：计算属性中不要写调用异步请求或者定时器，如果写了，异步处理完会再次调用这个计算属性
