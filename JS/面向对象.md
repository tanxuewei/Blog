# 对象

## 理解对象

数据属性

1. configurable: 可修改属性，默认为 true

2. enumerable: 可枚举，默认为 false

3. writable: 可修改属性的值，默认为 true

4. value: 包含这个属性的数据值，默认为 undefined

访问器属性

1. configurable: 可修改属性，默认为 true

2. enumerable: 可枚举，默认为 false

3. [[get]]: 在读取属性时调用的函数, 默认为 undefined

4. [[set]]: 在写入属性时调用的函数，默认为 undefined

```js
var book = {
  _year: 2004,
  edition: 1
}
Object.defineProperty(book, 'year', {
  get: function () {
    return this._year
  },

  set: function (newVal) {
    if (newVal > 2004) {
      this._year = newVal
      this.edition += newVal - 2004
    }
  }
})

book.year = 2005
console.log(book.edition)  // 2
```

注意：在 get 中不要返回自己，否则会栈溢出, get 中应该返回具体的值。

访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化

## 工厂模式

当我们有多个相似的对象而又不知道应该先使用哪种时，就可以考虑使用工厂模式。在该模式下，代码将会根据具体的输入或其他既定规则，自行决定创建哪种类型的对象。

```js
function createPerson(name) {
    var o = new Object();
    o.name = name;
    o.getName = function () {
        console.log(this.name);
    };

    return o;
}

var person1 = createPerson('kevin');
```

缺点：对象无法识别，因为所有的实例都指向一个，实例的原型都指向Object

## 构造函数模式

```js
function Person(name) {
    this.name = name;
    this.getName = function () {
        console.log(this.name);
    };

    return o;
}

var person1 = new Person('kevin');
```

优点：实例可以识别为一个特定的类型
缺点：每次创建实例时，每个方法都要被创建一次

## 构造函数+原型模式组合

```js
function Person(name) {
    this.name = name;
}

Person.prototype = {
    constructor: Person,
    getName: function () {
        console.log(this.name);
    }
};

var person1 = new Person();
```

优点：该共享的共享，该私有的私有，使用最广泛的方式

缺点：？