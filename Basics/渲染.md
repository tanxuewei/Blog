# 渲染

## 进程和线程

进程和线程是操作系统的基本概念。

进程是 CPU 资源分配的最小单位。(是能拥有资源和独立运行的最小单位)

线程是 CPU 调度的最小单位 (是建立在进程基础上的一次程序运行单位)

现在操作系统都是可以同时运行多个任务的，比如用浏览器上网的同时还可以听音乐。

对于操作系统来说，一个任务就是一个进程，比如打开一个浏览器就是启动了一个浏览器进程。

在一个进程内部，要同时做多件事，就需要同时运行多个‘子任务’，我们把进程内的子任务称为线程。

由于每个进程至少要做一件事，所以一个进程至少有一个线程。系统会给每个进程分配独立的内存，因此进程有他独立的资源。同一进程内的各个线程之间共享该进程的内存空间（包括代码段、数据集、堆等）。

比如进程就像是一个有边界的生产厂间，而线程就像是厂间内的一个个员工，可以自己做自己的事情，也可以相互配合做同一件事情。

当我们启动一个应用，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用的所有状态都会保存在这块内存中。

应用也许还会创建多个线程来辅助工作,这些线程可以共享这部分内存中的数据。如果应用关闭,进程会被终结,操作系统会释放相关内存。

## 浏览器的多进程架构

Chrome 采用多进程架构,其顶层存在一个 Browser process 用以协调浏览器的其它进程。

* 优点：

由于默认 新开 一个 tab 页面 新建 一个进程,所以单个 tab 页面崩溃不会影响到整个浏览器。

同样,第三方插件崩溃也不会影响到整个浏览器。

多进程可以充分利用现代 CPU 多核的优势。

方便使用沙盒模型隔离插件等进程,提高浏览器的稳定性。

* 缺点：

系统为浏览器新开的进程分配内存、CPU 等资源,所以内存和 CPU 的资源消耗也会更大。

不过 Chrome 在内存释放方面做的不错,基本内存都是能很快释放掉给其他程序运行的。

> TODO Chrome 怎么释放内存的？

## 浏览器的主要进程和职责

[浏览器进程](../Images/browser.jpeg)

多进程的浏览器

* Browser进程，浏览器的主进程（负责协调、主控），只有一个
  负责浏览器界面的显示与交互，各个页面的管理，创建和销毁其他进程。网络的资源管理、下载等
* 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
* GPU进程：最多一个，用于3D绘制
* 浏览器渲染进程（浏览器内核）：默认每个tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）

### 渲染进程（浏览器内核）,是多线程的

1. GUI渲染线程
    * 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。

    * 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行

    * 注意，GUI渲染线程与JS引擎线程是**互斥**的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
2. JS引擎线程
    * 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）

    * JS引擎线程负责解析Javascript脚本，运行代码。

    * JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序

    * 同样注意，GUI渲染线程与JS引擎线程是**互斥**的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

3. 事件触发线程
    * 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）

    * 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中

    * 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理

    * 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

4. 定时器线程
    * 传说中的setInterval与setTimeout所在线程

    * 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）

    * 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）

    * 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
5. 网络请求线程
    * 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求

    * 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

### 浏览器渲染流程

1. 解析 HTML文件，构建 DOM 树，同时浏览器主进程负责下载 CSS 文件

2. CSS 文件下载完成，解析 CSS 文件成树形的数据结构，然后结合成 DOM 树合并成 RenderObject 树

3. 布局 RenderObject 树（Layout/reflow），负责 RenderObject 树中元素的尺寸、位置等计算

4. 绘制 RenderObject 树（paint），绘制页面的像素信息

5. 浏览器主进程将默认的图层和复合图层交给 GPU 进程，GPU 进程再将各个图层合成 （composite）,最后显示出页面

### 几个问题

一. 为什么js是单线程的？

js为处理页面中用户的交互，假如有两个线程同时操作一个 DOM，一个修改一个删除，就会引起问题，这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。

当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，js 在最初就选择了单线程。

二. 为什么 JS 阻塞页面加载？

由于 JS 是可操纵 DOM 的，如果在修改这些元素属性同时渲染页面（即 JS 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果，浏览器设置 **GUI 渲染线程与 JS 线程为互斥** 的关系。

当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。

从上面我们可以推理出,由于 GUI 渲染线程与 JavaScript 执行线程是互斥的关系,

当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行。

因此如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯, 导致页面渲染加载阻塞的感觉。

三. CSS 加载会造成阻塞吗？

因为DOM 和 CSSOM 通常是并行构建的，所以 **CSS 加载不会阻塞 DOM 的解析**。

然而，由于 Render Tree 是依赖 DOM Tree 和 CSSOM Tree 的，所以他必须等到 CSSOM Tree 构建完成，也就是 CSS 资源加载完成（或者 CSS 资源加载失败）后，才能开始渲染。

因此，**CSS 加载会阻塞 DOM 的渲染**。因为 **GUI 渲染线程与 JavaScript 引擎为互斥**的关系，样式表会在后面的 js 执行前先加载执行完毕，所以 **CSS 会阻塞后面 js 的执行**。

四. DOMContentLoaded 与 load 的区别？

* DOMContentLoaded：仅当 DOM 解析完成后，不包括样式表、图片。
  当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等 CSSOM 构建完成才能执行。在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源的加载完成。

* 当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片等资源已经加载完毕。

* DOMContentLoaded -> load

五. 什么是 CPR，即关键路径渲染（Critical Rendering Path）? 如何优化？

关键渲染路径是浏览器将 HTML CSS JavaScript 转换为在屏幕上呈现的像素内容所经历的一系列步骤。也就是我们上面说的浏览器渲染流程。
为尽快完成首次渲染,我们需要最大限度减小以下三种可变因素:

* 关键资源的数量: 可能阻止网页首次渲染的资源。
* 关键路径长度: 获取所有关键资源所需的往返次数或总时间。
* 关键字节: 实现网页首次渲染所需的总字节数,等同于所有关键资源传送文件大小的总和。

1、优化 DOM

* 删除不必要的代码和注释包括空格,尽量做到最小化文件。

* 可以利用 GZIP 压缩文件。

* 结合 HTTP 缓存文件。

2、优化 CSSOM

缩小、压缩以及缓存同样重要，对于 CSSOM 我们前面重点提过了它会阻止页面呈现，因此我们可以从这方面考虑去优化。

* 减少关键 CSS 元素数量

* 当我们声明样式表时,请密切关注媒体查询的类型,它们极大地影响了 CRP 的性能 。

> 媒体查询的类型，怎么影响了 CRP 的性能
