# 从输入url到加载发生了什么

http: //baidu.com/index.html

1. 新开一个网络请求线程

2. 发送一个 HTTP 请求：首先是进行 DNS 解析，就是把域名解析成 IP。dns解析之后，进行 tcp 连接（三次握手、四次挥手），向服务端发送http报文（5层协议栈知识：），到达代理服务器（Nginx，好处：内外隔离、负载均衡、反向代理），代理服务器再转发到对应的服务器。服务器响应。

当我们发起一个 http 请求的时候，首先是进行 DNS 解析，就是把域名解析成 IP，这是因为整个网络过程中是使用IP来进行路由的。ip地址不容易记忆，但是域名不好以及，所以互联网使用域名就好了。(DNS 解析，使用UDP, 出错了没关系，因为使用频繁，所以不使用tcp无需三次握手，高效减少开销。dns报文设计简单没有加密，所以容易被劫持)

3. 浏览器接收到 http 数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）

## TCP 3次握手、4次挥手

握手

1. 客户端发送一个SYN报文给服务端，其中序列号为ISNc
2. 服务端收到后也发送自己的SYN报文作为相应，并包含初始化序列号ISNs。为了确认客户端的 SYN，服务端将其包含的 ISNc的数值加1作为返回的 ACK 数值。（因此，每发送一个SYN，序列号就会自动加1，如果出现丢失的情况，该SYN段将会重传）
3. 为了确认服务端的 SYN，客户端将 ISNs 的数值加1后作为返回的 ack的数值

挥手：TCP规定通过发送一个FIN段来发起关闭操作。只有当连接双方都完成关闭操作后，才构成一个完整关闭

1. 主动关闭者（通常为客户端）发送一个FIN报文指明接受者希望看到自己的当前的序列号K。FIN段还包含一个ACK段用于确认对方最后一次发来的数据。
2. 客户端将k+1作为ack的值，表示自己已经成功接收到主动关闭者发送的FIN。
3. 接着，服务端变为主动关闭者，发送自己自己的FIN，该报文段的序列号为L。（为什么要等，因为要等到客户端的报文都发送完，我接受完）
4. 为了完成连接的关闭，最后发送的报名段还包含一个ACK用于确认上一个FIN。（如果FIN丢失，将重新传输直到收到ACK确认为止）
